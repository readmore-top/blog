<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>链表常见题(5)-环</title>
    <link href="/posts/f482.html"/>
    <url>/posts/f482.html</url>
    
    <content type="html"><![CDATA[<h1 id="两个链表相交"><a href="#两个链表相交" class="headerlink" title="两个链表相交"></a>两个链表相交</h1><p>给定两个可能有环也可能无环的单链表，头节点 <code>head1</code> 和 <code>head2</code>。请实现一个函数，如果两个链表相交，请返回相交的 第一个节点。如果不相交，返回 <code>null</code></p><p><strong>要求：</strong>如果两个链表长度之和为 <code>N</code>，时间复杂度请达到 <code>O(N)</code>，额外空间复杂度 请达到 <code>O(1)</code>。</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> loop;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FindFirstIntersectNode</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * head1和head2是可能有环也可能无环的单链表</span><span class="hljs-comment">     * &lt;p如果两个链表相交，请返回相交的 第一个节点，如果不相交，返回&lt;code&gt;null&lt;/code&gt;&lt;/p&gt;</span><span class="hljs-comment">     * &lt;p&gt;时间复杂度：O(n)&lt;/p&gt;</span><span class="hljs-comment">     * &lt;p&gt;额外空间复杂度：O(1)&lt;/p&gt;</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> head1 链表1</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> head2 链表2</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 相交第一个节点或者&lt;code&gt;null&lt;/code&gt;</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">getIntersectNode</span><span class="hljs-params">(Node head1, Node head2)</span> </span>&#123;        <span class="hljs-comment">// 链表head1第一个入环节点</span>        Node loop1 = getLoopNode(head1);        <span class="hljs-comment">// 链表head2第一个入环节点</span>        Node loop2 = getLoopNode(head2);        <span class="hljs-comment">// 情况1：都无环时</span>        <span class="hljs-keyword">if</span> (loop1 == <span class="hljs-keyword">null</span> &amp;&amp; loop2 == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> noLoop(head1, head2);        &#125;        <span class="hljs-comment">// 情况2：都有环时</span>        <span class="hljs-keyword">if</span> (loop1 != <span class="hljs-keyword">null</span> &amp;&amp; loop2 != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> bothLoop(head1, loop1, head2, loop2);        &#125;        <span class="hljs-comment">// 情况3：一个有环，一个无环</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 找到链表第一个入环节点，如果无环，返回&lt;code&gt;null&lt;/code&gt;</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> head 链表</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 有环返回一个入环节点，无环返回&lt;code&gt;null&lt;/code&gt;</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">getLoopNode</span><span class="hljs-params">(Node head)</span> </span>&#123;        <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span> || head.next.next == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-comment">// 快慢双指针</span>        Node slow = head.next;        Node fast = head.next.next;        <span class="hljs-keyword">while</span> (slow != fast) &#123;            <span class="hljs-comment">// 快指针走两步</span>            <span class="hljs-keyword">if</span> (fast.next == <span class="hljs-keyword">null</span> || fast.next.next == <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;            &#125;            fast = fast.next.next;            <span class="hljs-comment">// 慢指针走一步</span>            slow = slow.next;        &#125;        <span class="hljs-comment">// 有环，快指针回到头节点</span>        fast = head;        <span class="hljs-comment">// 快慢指针一起走，一次走一步，相遇时就是第一个入环节点</span>        <span class="hljs-keyword">while</span> (slow != fast) &#123;            fast = fast.next;            slow = slow.next;        &#125;        <span class="hljs-keyword">return</span> slow;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 如果两个链表都无环，返回第一个相交节点，如果不想交，返回&lt;code&gt;null&lt;/code&gt;</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> head1 链表1</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> head2 链表2</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 相交返回第一个相交节点，如果不想交，返回&lt;code&gt;null&lt;/code&gt;</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">noLoop</span><span class="hljs-params">(Node head1, Node head2)</span> </span>&#123;        <span class="hljs-comment">// 特殊值判断</span>        <span class="hljs-keyword">if</span> (head1 == <span class="hljs-keyword">null</span> || head2 == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-comment">// 链表head1与链表head2长度的差值</span>        <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 链表head1的尾节点</span>        Node cur1 = head1;        <span class="hljs-keyword">while</span> (cur1.next != <span class="hljs-keyword">null</span>) &#123;            cur1 = cur1.next;            n++;        &#125;        <span class="hljs-comment">// 链表head2的尾节点</span>        Node cur2 = head2;        <span class="hljs-keyword">while</span> (cur2.next != <span class="hljs-keyword">null</span>) &#123;            cur2 = cur2.next;            n--;        &#125;        <span class="hljs-comment">// 尾节点不相同，不相交</span>        <span class="hljs-keyword">if</span> (cur1 != cur2) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-comment">// 长链表</span>        cur1 = n &gt; <span class="hljs-number">0</span> ? head1 : head2;        <span class="hljs-comment">// 短链表</span>        cur2 = cur1 == head1 ? head2 : head1;        <span class="hljs-comment">// 长链表先走 |n|步</span>        n = Math.abs(n);        <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;            cur1 = cur1.next;            n--;        &#125;        <span class="hljs-comment">// 长短链表一起走，相遇时即第一个相交节点</span>        <span class="hljs-keyword">while</span> (cur1 != cur2) &#123;            cur1 = cur1.next;            cur2 = cur2.next;        &#125;        <span class="hljs-keyword">return</span> cur1;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 两个有环链表，返回第一个相交节点，如果不想交返回&lt;code&gt;null&lt;/code&gt;</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> head1 链表1</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> loop1 链表1入环节点</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> head2 链表2</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> loop2 链表2入环节点</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 相交返回第一个相交节点，如果不想交，返回&lt;code&gt;null&lt;/code&gt;</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">bothLoop</span><span class="hljs-params">(Node head1, Node loop1, Node head2, Node loop2)</span> </span>&#123;        Node cur1, cur2;        <span class="hljs-comment">// 入环节点相同</span>        <span class="hljs-keyword">if</span> (loop1 == loop2) &#123;            <span class="hljs-comment">// 链表head1与链表head2长度的差值</span>            <span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>;            <span class="hljs-comment">// 链表head1的尾节点</span>            cur1 = head1;            <span class="hljs-keyword">while</span> (cur1 != loop1) &#123;                cur1 = cur1.next;                n++;            &#125;            <span class="hljs-comment">// 链表head2的尾节点</span>            cur2 = head2;            <span class="hljs-keyword">while</span> (cur2 != loop2) &#123;                cur2 = cur2.next;                n--;            &#125;            <span class="hljs-comment">// 长链表</span>            cur1 = n &gt; <span class="hljs-number">0</span> ? head1 : head2;            <span class="hljs-comment">// 短链表</span>            cur2 = cur1 == head1 ? head2 : head1;            <span class="hljs-comment">// 长链表先走 |n|步</span>            n = Math.abs(n);            <span class="hljs-keyword">while</span> (n != <span class="hljs-number">0</span>) &#123;                cur1 = cur1.next;                n--;            &#125;            <span class="hljs-comment">// 长短链表一起走，相遇时即第一个相交节点</span>            <span class="hljs-keyword">while</span> (cur1 != cur2) &#123;                cur1 = cur1.next;                cur2 = cur2.next;            &#125;            <span class="hljs-keyword">return</span> cur1;        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 入环节点不相同</span>            <span class="hljs-comment">// head1的环内节点</span>            cur1 = loop1.next;            <span class="hljs-keyword">while</span> (cur1 != loop1) &#123;                <span class="hljs-comment">// 当head1的环内节点中有loop2时说明两链表相交</span>                <span class="hljs-keyword">if</span> (cur1 == loop2) &#123;                    <span class="hljs-keyword">return</span> loop1;                &#125;                cur1 = cur1.next;            &#125;            <span class="hljs-comment">// 两链表不相交</span>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> value;        <span class="hljs-keyword">public</span> Node next;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;            <span class="hljs-keyword">this</span>.value = data;        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>链表</tag>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表常见题(4)-荷兰国旗</title>
    <link href="/posts/d23a.html"/>
    <url>/posts/d23a.html</url>
    
    <content type="html"><![CDATA[<p>将单向链表按某值划分成<strong>左边小</strong>、<strong>中间相等</strong>、<strong>右边大</strong>的形式</p><ul><li>把链表放入数组里，在数组上做 <code>partition</code>（笔试用）</li><li>分成小、中、大三部分，再把各个部分之间串起来（面试用）</li></ul><pre><code class="hljs java"><span class="hljs-keyword">package</span> size;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmallerEqualBigger</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 将单向链表按某值划分成左边小、中间相等、右边大的形式</span><span class="hljs-comment">     * &lt;p&gt;链表直接实现：分成小、中、大三部分，再把各个部分之间串起来&lt;/p&gt;</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> root  head</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> pivot 比较值</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 划分后的链表</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">listPartition</span><span class="hljs-params">(Node root, <span class="hljs-keyword">int</span> pivot)</span> </span>&#123;        <span class="hljs-comment">// head -&gt; 小于/等于/大于</span>        Node sH = <span class="hljs-keyword">null</span>, eH = <span class="hljs-keyword">null</span>, mH = <span class="hljs-keyword">null</span>;        <span class="hljs-comment">// tail -&gt; 小于/等于/大于</span>        Node sT = <span class="hljs-keyword">null</span>, eT = <span class="hljs-keyword">null</span>, mT = <span class="hljs-keyword">null</span>;        <span class="hljs-comment">// 下一个指针</span>        Node next;        <span class="hljs-keyword">while</span> (root != <span class="hljs-keyword">null</span>) &#123;            next = root.next;            root.next = <span class="hljs-keyword">null</span>;            <span class="hljs-keyword">if</span> (root.value &lt; pivot) &#123;                <span class="hljs-keyword">if</span> (sH == <span class="hljs-keyword">null</span>) &#123;                    sH = root;                &#125; <span class="hljs-keyword">else</span> &#123;                    sT.next = root;                &#125;                sT = root;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.value &gt; pivot) &#123;                <span class="hljs-keyword">if</span> (mH == <span class="hljs-keyword">null</span>) &#123;                    mH = root;                &#125; <span class="hljs-keyword">else</span> &#123;                    mT.next = root;                &#125;                mT = root;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">if</span> (eH == <span class="hljs-keyword">null</span>) &#123;                    eH = root;                &#125; <span class="hljs-keyword">else</span> &#123;                    eT.next = root;                &#125;                eT = root;            &#125;            root = next;        &#125;        <span class="hljs-comment">// 将三个链表链接起来</span>        <span class="hljs-keyword">if</span> (sT != <span class="hljs-keyword">null</span>) &#123;            sT.next = eH;            eT = eT == <span class="hljs-keyword">null</span> ? sT : eT;        &#125;        <span class="hljs-keyword">if</span> (eT != <span class="hljs-keyword">null</span>) &#123;            eT.next = mH;        &#125;        <span class="hljs-keyword">return</span> sH != <span class="hljs-keyword">null</span> ? sH : (eH != <span class="hljs-keyword">null</span> ? eH : mT);    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> value;        <span class="hljs-keyword">public</span> Node next;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;            <span class="hljs-keyword">this</span>.value = data;        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>链表</tag>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表常见题(3)-克隆链表</title>
    <link href="/posts/d6ef.html"/>
    <url>/posts/d6ef.html</url>
    
    <content type="html"><![CDATA[<h1 id="克隆链表"><a href="#克隆链表" class="headerlink" title="克隆链表"></a>克隆链表</h1><p>一种特殊的单链表节点类描述如下：</p><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123; <span class="hljs-keyword">int</span> value; Node next; Node rand; Node(<span class="hljs-keyword">int</span> val) &#123;    value = val;  &#125; &#125;</code></pre><p><code>rand</code>指针是单链表节点结构中新增的指针，<code>rand</code>可能指向链表中的任意一个节点，也可能指向<code>null</code>。</p><p><strong>要求：</strong>给定一个由<code>Node</code>节点类型组成的无环单链表的头节点<code>head</code>，请实现一个函数完成这个链表的复制，并返回复制的新链表的头节点。</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> copy;<span class="hljs-keyword">import</span> java.util.HashMap;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CopyListWithRandom</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 链表复制</span><span class="hljs-comment">     * &lt;p&gt;使用Hash表实现&lt;/p&gt;</span><span class="hljs-comment">     * &lt;p&gt;时间复杂度：O(n)&lt;/p&gt;</span><span class="hljs-comment">     * &lt;p&gt;额外空间复杂度：O(n)&lt;/p&gt;</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> root head</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 复制的链表</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">copyListWithRand1</span><span class="hljs-params">(Node root)</span> </span>&#123;        <span class="hljs-comment">// 特殊值判断</span>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-comment">// 定义Hash表，构造老节点与新节点的对应关系</span>        HashMap&lt;Node, Node&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        Node old = root;        <span class="hljs-keyword">while</span> (old != <span class="hljs-keyword">null</span>) &#123;            map.put(old, <span class="hljs-keyword">new</span> Node(old.value));            old = old.next;        &#125;        <span class="hljs-comment">// 构造复制的节点的链表关系</span>        old = root;        <span class="hljs-keyword">while</span> (old != <span class="hljs-keyword">null</span>) &#123;            map.get(old).next = map.get(old.next);            map.get(old).rand = map.get(old.rand);            old = old.next;        &#125;        <span class="hljs-keyword">return</span> map.get(root);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 链表复制</span><span class="hljs-comment">     * &lt;p&gt;不用Hash链表构造新老节点对应关系&lt;/p&gt;</span><span class="hljs-comment">     * &lt;p&gt;将新节点始终放在老节点的next来构造对应关系&lt;/p&gt;</span><span class="hljs-comment">     * &lt;p&gt;时间复杂度：O(n)&lt;/p&gt;</span><span class="hljs-comment">     * &lt;p&gt;额外空间复杂度：O(1)&lt;/p&gt;</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> root head</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 复制的链表</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">copyListWithRand2</span><span class="hljs-params">(Node root)</span> </span>&#123;        <span class="hljs-comment">// 特殊值判断</span>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-comment">// 新建新节点，构造新老节点对应关系</span>        Node next;        Node old = root;        <span class="hljs-keyword">while</span> (old != <span class="hljs-keyword">null</span>) &#123;            next = old.next;            Node node = <span class="hljs-keyword">new</span> Node(old.value);            node.next = next;            old.next = node;            old = next;        &#125;        <span class="hljs-comment">// 复制老节点的rand关系</span>        old = root;        <span class="hljs-keyword">while</span> (old != <span class="hljs-keyword">null</span>) &#123;            old.next.rand = old.rand == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : old.rand.next;            old = old.next.next;        &#125;        <span class="hljs-comment">// 分离新老链表</span>        old = root;        Node head = old.next;        <span class="hljs-keyword">while</span> (old != <span class="hljs-keyword">null</span>) &#123;            next = old.next;            old.next = next.next;            old = old.next;            next.next = old == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : old.next;        &#125;        <span class="hljs-keyword">return</span> head;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> value;        <span class="hljs-keyword">public</span> Node next;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * rand指针是单链表节点结构中新增的指针</span><span class="hljs-comment">         * rand可能指向链表中的任意一个节点</span><span class="hljs-comment">         * 也可能指向null</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">public</span> Node rand;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;            <span class="hljs-keyword">this</span>.value = data;        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>链表</tag>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表常见题(2)-判断回文</title>
    <link href="/posts/6522.html"/>
    <url>/posts/6522.html</url>
    
    <content type="html"><![CDATA[<h1 id="判断回文"><a href="#判断回文" class="headerlink" title="判断回文"></a>判断回文</h1><p>给定一个单链表的头节点 <code>head</code> ，请判断该链表是否为回文结构</p><ul><li><p><strong>堆栈</strong>方法特别简单（笔试用）</p></li><li><p>改原链表的方法就需要注意边界了（面试用）</p></li></ul><pre><code class="hljs java"><span class="hljs-keyword">package</span> palindrome;<span class="hljs-keyword">import</span> java.util.Stack;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PalindromeList</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 请判断该链表是否为回文结构</span><span class="hljs-comment">     * &lt;p&gt;额外空间复杂度O(n)&lt;/p&gt;</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> root head</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 回文返回&lt;code&gt;true&lt;/code&gt;，否则返回&lt;code&gt;false&lt;/code&gt;</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindromeList1</span><span class="hljs-params">(Node root)</span> </span>&#123;        <span class="hljs-comment">// 边界判断</span>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span> || root.next == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-comment">// 定义栈</span>        Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();        <span class="hljs-comment">// 将链表放入栈中(可以取链表的中点放入一半进入栈进行优化)</span>        Node cur = root;        <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;            stack.push(cur.value);            cur = cur.next;        &#125;        <span class="hljs-comment">// 比较值</span>        cur = root;        <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">if</span> (cur.value != stack.pop()) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            &#125;            cur = cur.next;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 请判断该链表是否为回文结构</span><span class="hljs-comment">     * &lt;p&gt;额外空间复杂度O(1)&lt;/p&gt;</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> root head</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 回文返回&lt;code&gt;true&lt;/code&gt;，否则返回&lt;code&gt;false&lt;/code&gt;</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindromeList2</span><span class="hljs-params">(Node root)</span> </span>&#123;        <span class="hljs-comment">// 边界判断</span>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span> || root.next == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;        <span class="hljs-comment">// 快慢双指针取中点（奇数长度为中点，偶数长度为上中点）</span>        Node n1 = root;        Node n2 = root;        <span class="hljs-keyword">while</span> (n2.next != <span class="hljs-keyword">null</span> &amp;&amp; n2.next.next != <span class="hljs-keyword">null</span>) &#123;            n1 = n1.next;            n2 = n2.next.next;        &#125;        <span class="hljs-comment">// 将中点后的节点逆序</span>        Node after = n1.next;        n1.next = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">while</span> (after != <span class="hljs-keyword">null</span>) &#123;            n2 = after.next;            after.next = n1;            n1 = after;            after = n2;        &#125;        <span class="hljs-comment">// 链表前后比较</span>        after = n1;        n2 = root;        <span class="hljs-keyword">boolean</span> result = <span class="hljs-keyword">true</span>;        <span class="hljs-keyword">while</span> (n2 != <span class="hljs-keyword">null</span> &amp;&amp; n1 != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">if</span> (n2.value != n1.value) &#123;                result = <span class="hljs-keyword">false</span>;                <span class="hljs-keyword">break</span>;            &#125;            n1 = n1.next;            n2 = n2.next;        &#125;        <span class="hljs-comment">// 将链表还原</span>        n1 = after;        after = n1.next;        n1.next = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">while</span> (after != <span class="hljs-keyword">null</span>) &#123;            n2 = after.next;            after.next = n1;            n1 = after;            after = n2;        &#125;        <span class="hljs-keyword">return</span> result;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> value;        <span class="hljs-keyword">public</span> Node next;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span> </span>&#123;            <span class="hljs-keyword">this</span>.value = data;        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>链表</tag>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表常见题(1)-找中点</title>
    <link href="/posts/3995.html"/>
    <url>/posts/3995.html</url>
    
    <content type="html"><![CDATA[<h1 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h1><ul><li>输入链表头节点，奇数长度返回中点，偶数长度返回上中点</li><li>输入链表头节点，奇数长度返回中点，偶数长度返回下中点</li><li>输入链表头节点，奇数长度返回中点前一个，偶数长度返回上中点前一个</li><li>输入链表头节点，奇数长度返回中点前一个，偶数长度返回下中点前一个</li></ul><pre><code class="hljs java"><span class="hljs-keyword">package</span> mid;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedListMid</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 输入链表头节点，奇数长度返回中点，偶数长度返回上中点</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> root head</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 中点</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">midOrUpMidNode</span><span class="hljs-params">(Node root)</span> </span>&#123;        <span class="hljs-comment">// 边界情况</span>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span> || root.next == <span class="hljs-keyword">null</span> || root.next.next == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> root;        &#125;        <span class="hljs-comment">// 快慢双指针</span>        Node slow = root.next;        Node fast = root.next.next;        <span class="hljs-keyword">while</span> (fast.next != <span class="hljs-keyword">null</span> &amp;&amp; fast.next.next != <span class="hljs-keyword">null</span>) &#123;            slow = slow.next;            fast = fast.next.next;        &#125;        <span class="hljs-keyword">return</span> slow;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 输入链表头节点，奇数长度返回中点，偶数长度返回下中点</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> root head</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 中点</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">midOrDownMidNode</span><span class="hljs-params">(Node root)</span> </span>&#123;        <span class="hljs-comment">// 边界情况</span>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span> || root.next == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> root;        &#125;        <span class="hljs-comment">// 快慢双指针</span>        Node slow = root.next;        Node fast = root.next;        <span class="hljs-keyword">while</span> (fast.next != <span class="hljs-keyword">null</span> &amp;&amp; fast.next.next != <span class="hljs-keyword">null</span>) &#123;            slow = slow.next;            fast = fast.next.next;        &#125;        <span class="hljs-keyword">return</span> slow;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 输入链表头节点，奇数长度返回中点前一个，偶数长度返回上中点前一个</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> root head</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 中点</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">midOrUpMidPreNode</span><span class="hljs-params">(Node root)</span> </span>&#123;        <span class="hljs-comment">// 边界情况</span>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span> || root.next == <span class="hljs-keyword">null</span> || root.next.next == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-comment">// 快慢双指针</span>        Node slow = root;        Node fast = root.next.next;        <span class="hljs-keyword">while</span> (fast.next != <span class="hljs-keyword">null</span> &amp;&amp; fast.next.next != <span class="hljs-keyword">null</span>) &#123;            slow = slow.next;            fast = fast.next.next;        &#125;        <span class="hljs-keyword">return</span> slow;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 输入链表头节点，奇数长度返回中点前一个，偶数长度返回下中点前一个</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> root head</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 中点</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Node <span class="hljs-title">midOrDownMidPreNode</span><span class="hljs-params">(Node root)</span> </span>&#123;        <span class="hljs-comment">// 边界情况</span>        <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span> || root.next == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;        <span class="hljs-keyword">if</span> (root.next.next == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> root;        &#125;        <span class="hljs-comment">// 快慢双指针</span>        Node slow = root;        Node fast = root.next;        <span class="hljs-keyword">while</span> (fast.next != <span class="hljs-keyword">null</span> &amp;&amp; fast.next.next != <span class="hljs-keyword">null</span>) &#123;            slow = slow.next;            fast = fast.next.next;        &#125;        <span class="hljs-keyword">return</span> slow;    &#125;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> value;        <span class="hljs-keyword">public</span> Node next;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> </span>&#123;            value = v;        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>链表</tag>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/posts/3eeb.html"/>
    <url>/posts/3eeb.html</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="hljs bash">$ hexo new <span class="hljs-string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="hljs bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="hljs bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="hljs bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
